=encoding UTF-8

=head1 Name

sqitchtutorial-snowflake - A tutorial introduction to Sqitch change management on Snowflake

=head1 Synopsis

  sqitch *

=head1 Description

This tutorial explains how to create a sqitch-enabled Snowflake project, use a
VCS for deployment planning, and work with other developers to make sure
changes remain in sync and in the proper order.

We'll start by creating a new project from scratch, a fictional antisocial
networking site called Flipr. All examples use L<Git|http://git-scm.com/> as
the VCS and L<Snowflake|https://www.snowflake.net/> as the storage engine, but
for the most part you can substitute other VCSes and database engines in the
examples as appropriate.

If you'd like to manage a PostgreSQL database, see L<sqitchtutorial>.

If you'd like to manage an SQLite database, see L<sqitchtutorial-sqlite>.

If you'd like to manage an Oracle database, see L<sqitchtutorial-oracle>.

If you'd like to manage a MySQL database, see L<sqitchtutorial-mysql>.

If you'd like to manage a Firebird database, see L<sqitchtutorial-firebird>.

If you'd like to manage a Vertica database, see L<sqitchtutorial-vertica>.

If you'd like to manage an Exasol database, see L<sqitchtutorial-exasol>.

=head2 Connection Configuration

Sqitch requires ODBC to connect to the Snowflake database. As such, you'll
need to make sure that the
L<Snowflake ODBC driver|https://docs.snowflake.net/manuals/user-guide/odbc.html>
is installed and properly configured. At its simplest, on Unix-like systems,
name the driver "Snowflake" by adding this entry to C<odbcinst.ini> (usually
found in C</etc>, C</usr/etc>, or C</usr/local/etc>):

  [Snowflake]
  Description = ODBC for Snowflake
  Driver      = /usr/lib64/snowflake/odbc/lib/libSnowflake.so

Note that you'll need to adjust the path depending on the version of the ODBC
driver, and where you installed it.


See the L<Snowflake ODBC documentation|https://docs.snowflake.net/manuals/user-guide/odbc.html>
for details on downloading, installling, and configuring ODBC for your
platform.

=head1 Starting a New Project

Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:

  > mkdir flipr
  > cd flipr
  > git init .
  Initialized empty Git repository in /flipr/.git/
  > touch README.md
  > git add .
  > git commit -am 'Initialize project, add README.'

If you're a Git user and want to follow along the history, the repository
used in these examples is
L<on GitHub|https://github.com/sqitchers/sqitch-snowflake-intro>.

Now that we have a repository, let's get started with Sqitch. Every Sqitch
project must have a name associated with it, and, optionally, a unique URI. We
recommend including the URI, as it increases the uniqueness of object
identifiers internally, so let's specify one when we initialize Sqitch:

  > sqitch init flipr --uri https://github.com/sqitchers/sqitch-snowflake-intro/ --engine snowflake
  Created sqitch.conf
  Created sqitch.plan
  Created deploy/
  Created revert/
  Created verify/

Let's have a look at F<sqitch.conf>:

  > cat sqitch.conf
  [core]
    engine = snowflake
    # plan_file = sqitch.plan
    # top_dir = .
  # [engine "snowflake"]
    # target = db:snowflake:
    # registry = sqitch
    # client = snowsql

Good, it picked up on the fact that we're creating changes for the Snowflake
engine, thanks to the C<--engine snowflake> option, and saved it to the
file. Furthermore, it wrote a commented-out C<[engine "snowflake"]> section with
all the available Snowflake engine-specific settings commented out and ready to
be edited as appropriate.

By default, Sqitch will read F<sqitch.conf> in the current directory for
settings. But it will also read F<~/.sqitch/sqitch.conf> for user-specific
settings. Since Snowflake's C<snowsql> client is not in the path on my system,
let's go ahead an tell it where to find the client on our computer:

  > sqitch config --user engine.snowflake.client /Applications/SnowSQL.app/Contents/MacOS/snowsql

And let's also tell it who we are, since this data will be used in all
of our projects:

  > sqitch config --user user.name 'Marge N. O’Vera'
  > sqitch config --user user.email 'marge@example.com'

Have a look at F<~/.sqitch/sqitch.conf> and you'll see this:

  > cat ~/.sqitch/sqitch.conf
  [engine "snowflake"]
    client = /Applications/SnowSQL.app/Contents/MacOS/snowsql
  [user]
    name = Marge N. O’Vera
    email = marge@example.com

Which means that Sqitch should be able to find C<snowsql> for any project, and
that it will always properly identify us when planning and committing changes.

Back to the repository. Have a look at the plan file, F<sqitch.plan>:

  > cat sqitch.plan
  %syntax-version=1.0.0
  %project=flipr
  %uri=https://github.com/sqitchers/sqitch-snowflake-intro/


Note that it has picked up on the name and URI of the app we're building.
Sqitch uses this data to manage cross-project dependencies. The
C<%syntax-version> pragma is always set by Sqitch, so that it always knows how
to parse the plan, even if the format changes in the future.

Let's commit these changes and start creating the database changes.

  > git add .
  > git commit -am 'Initialize Sqitch configuration.'
  [master b731cc3] Initialize Sqitch configuration.
   2 files changed, 15 insertions(+)
   create mode 100644 sqitch.conf
   create mode 100644 sqitch.plan

=head1 Our First Change

First, our project will need a schema. This creates a nice namespace for all
of the objects that will be part of the flipr app. Run this command:

  > sqitch add appschema -n 'Add schema for all flipr objects.'
  Created deploy/appschema.sql
  Created revert/appschema.sql
  Created verify/appschema.sql
  Added "appschema" to sqitch.plan

The L<C<add>|sqitch-add> command adds a database change to the plan and writes
deploy, revert, and verify scripts that represent the change. Now we edit
these files. The C<deploy> script's job is to create the schema. So we add
this to F<deploy/appschema.sql>:

  CREATE SCHEMA flipr;

The C<revert> script's job is to precisely revert the change to the deploy
script, so we add this to F<revert/appschema.sql>:

  DROP SCHEMA flipr;

Now we can try deploying this change. We tell Sqitch where to send the change
via a L<database URI|https://github.com/libwww-perl/uri-db/>. Let's say we're
using the account name C<example>, username C<movera>, database C<flipr>, and
workspace C<sqitch>, and an ODBC driver named C<Snowflake>
(see L</Connection Configuration> for details). The URI would be structured
like this:

  db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch

Note that Sqitch requires a workspace in order to record its work in the
registry. The default workspace is named C<sqitch>, so you can omit it from
the URI if that's the workspace you want Sqitch to use. Otherwise, specify it
in the URI. Snowflake also requires a password, which could also be included
in the URI, but it's best to put it in the C<connections> section of the
L<F<.snowsql/config> file|https://docs.snowflake.net/manuals/user-guide/snowsql-start.html#configuring-default-connection-settings>. See L<sqitch-passwords> for details.

We just tell Sqitch to use that URI to deploy the change:

  > sqitch deploy 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  Adding registry tables to db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  Deploying changes to db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
    + appschema .. ok

First Sqitch created registry tables used to track database changes. The
structure and name of the registry varies between databases (Snowflake uses a
schema to namespace its registry, while SQLite and MySQL use separate
databases). Next, Sqitch deploys changes. We only have one so far; the C<+>
reinforces the idea that the change is being C<added> to the database.

Note that this process can take quite a bit of time. Sqitch connects to the
database via ODBC and retains the connection throughout, but the creation of
the registry and all change scripts run through individual runs of C<snowsql>.
These connections can be quite slow. So if Sqitch seems hung, just wait; it's
most likely waiting on Snowflake.

With this change deployed, if you connect to the database, you'll be able to
see the schema:

  > snowsql --accountname example --username movera --dbname flipr \
    --query "SHOW TERSE SCHEMAS LIKE 'flipr'"
  * SnowSQL * v1.1.59
  Type SQL statements or !help
  +-------------------------------+-------+------+---------------+-------------+
  | created_on                    | name  | kind | database_name | schema_name |
  |-------------------------------+-------+------+---------------+-------------|
  | 2018-07-25 21:12:59.174 +0000 | FLIPR | NULL | DWHEELER      | NULL        |
  +-------------------------------+-------+------+---------------+-------------+
  1 Row(s) produced. Time Elapsed: 0.283s

=head2 Trust, But Verify

But that's too much work. Do you really want to do something like that after
every deploy?

Here's where the C<verify> script comes in. Its job is to test that the deploy
did was it was supposed to. It should do so without regard to any data that
might be in the database, and should throw an error if the deploy was not
successful. In Snowflake, the simplest way to do so for schema is probably to
simply create an object in the schema. Put this SQL into
F<verify/appschema.sql>:

  CREATE TEMPORARY TABLE flipr.verify__ (id INT);

In truth, you can use I<any> query that generates an SQL error if the schema
doesn't exist. Another handy way to do that is to divide by zero if an object
doesn't exist. For example, to throw an error when the C<flipr> schema does
not exist, you could do something like this:

  USE WAREHOUSE &warehouse;
  SELECT 1/COUNT(*) FROM information_schema.schemata WHERE schema_name = 'FLIPR';

Note the C<USE WAREHOUSE> statement. For scripts that execute queries requiring
compute resources (typically DML and C<SELECT> statements), we'll need to use a
L<virtual warehouse|https://docs.snowflake.net/manuals/user-guide/warehouses.html>.
To use the warehouse that Sqitch itself uses for its registry, you can use the
C<&warehouse> C<snowsql> variable, as in this example. Sqitch always sets This
variable for all deploy, revert, and verify script executions.

Now run the C<verify> script with the L<C<verify>|sqitch-verify> command:

  > sqitch verify 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
    * appschema .. ok
  Verify successful

Looks good! If you want to make sure that the verify script correctly dies if
the schema doesn't exist, temporarily change the schema name in the script to
something that doesn't exist, something like:

  CREATE TEMPORARY TABLE nonesuch.verify__ (id INT);

Then L<C<verify>|sqitch-verify> again:

  > sqitch verify 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  * appschema ..
  002003 (02000): SQL compilation error:
  Schema 'FLIPR.NONESUCH' does not exist.
  # Verify script "verify/appschema.sql" failed.
  not ok

  Verify Summary Report
  ---------------------
  Changes: 1
  Errors:  1
  Verify failed

It's even nice enough to tell us what the problem is. Or, for the
divide-by-zero example, change the schema name:

  USE WAREHOUSE &warehouse;
  SELECT 1/COUNT(*) FROM information_schema.schemata WHERE schema_name = 'NONESUCH';

Then the verify will look something like:

  > sqitch verify 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  * appschema ..
  100051 (22012): Division by zero
  # Verify script "verify/appschema.sql" failed.
  not ok

  Verify Summary Report
  ---------------------
  Changes: 1
  Errors:  1
  Verify failed

Less useful error output, but enough to alert us that something has gone
wrong.

Don't forget to change the schema name back before continuing!

=head2 Status, Revert, Log, Repeat

For purely informational purposes, we can always see how a deployment was
recorded via the L<C<status>|sqitch-status> command, which reads the registry
tables from the database:

  > sqitch status 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  # On database db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  # Project:  flipr
  # Change:   72ff6480c94724d772dae4136420e807688badb8
  # Name:     appschema
  # Deployed: 2018-07-25 14:56:32 -0400
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)

Let's make sure that we can revert the change:

  > sqitch revert 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  Revert all changes from db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch? [Yes]
    - appschema .. ok

The L<C<revert>|sqitch-revert> command first prompts to make sure that we
really do want to revert. This is to prevent unnecessary accidents. You can
pass the C<-y> option to disable the prompt. Also, notice the C<-> before the
change name in the output, which reinforces that the change is being
I<removed> from the database. And now the schema should be gone:

  > snowsql --accountname example --username movera --dbname flipr \
    --query "SHOW TERSE SCHEMAS LIKE 'flipr'"
  * SnowSQL * v1.1.59
  Type SQL statements or !help
  +------------+------+------+---------------+-------------+
  | created_on | name | kind | database_name | schema_name |
  |------------+------+------+---------------+-------------|
  +------------+------+------+---------------+-------------+
  0 Row(s) produced. Time Elapsed: 0.204s

And the status message should reflect as much:

  > sqitch status 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  # On database db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  No changes deployed

Of course, since nothing is deployed, the L<C<verify>|sqitch-verify> command
has nothing to verify:

  > sqitch verify 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  No changes deployed

However, we still have a record that the change happened, visible via the
L<C<log>|sqitch-log> command:

  > sqitch log 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  On database db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  Revert 72ff6480c94724d772dae4136420e807688badb8
  Name:      appschema
  Committer: Marge N. O’Vera <marge@example.com>
  Date:      2018-07-25 16:48:33 -0400

      Add schema for all flipr objects.

  Deploy 72ff6480c94724d772dae4136420e807688badb8
  Name:      appschema
  Committer: Marge N. O’Vera <marge@example.com>
  Date:      2018-07-25 14:56:33 -0400

      Add schema for all flipr objects.

Note that the actions we took are shown in reverse chronological order, with
the revert first and then the deploy.

Cool. Now let's commit it.

  > git add .
  > git commit -m 'Add flipr schema.'
  [master b0c5544] Add flipr schema.
  4 files changed, 10 insertions(+)
  create mode 100644 deploy/appschema.sql
  create mode 100644 revert/appschema.sql
  create mode 100644 verify/appschema.sql

And then deploy again. This time, let's use the C<--verify> option, so that
the C<verify> script is applied when the change is deployed:

  > sqitch deploy --verify 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  Deploying changes to db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
    + appschema .. ok

And now the schema should be back:

  > snowsql --accountname example --username movera --dbname flipr \
    --query "SHOW TERSE SCHEMAS LIKE 'flipr'"
  * SnowSQL * v1.1.59
  Type SQL statements or !help
  +-------------------------------+-------+------+---------------+-------------+
  | created_on                    | name  | kind | database_name | schema_name |
  |-------------------------------+-------+------+---------------+-------------|
  | 2018-07-25 21:12:59.174 +0000 | FLIPR | NULL | DWHEELER      | NULL        |
  +-------------------------------+-------+------+---------------+-------------+
  1 Row(s) produced. Time Elapsed: 0.283s

When we look at the status, the deployment will be there:

  > sqitch status 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'
  # On database db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
  # Project:  flipr
  # Change:   72ff6480c94724d772dae4136420e807688badb8
  # Name:     appschema
  # Deployed: 2018-07-25 17:35:46 -0400
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)

=head1 On Target

I'm getting a little tired of always having to type
C<db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch>, aren't you?
This L<database connection URI|https://github.com/libwww-perl/uri-db/> tells
Sqitch how to connect to the deployment target, but we don't have to keep
using the URI. We can name the target:

  > sqitch target add flipr_test 'db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch'

The L<C<target>|sqitch-target> command, inspired by
L<C<git-remote>|http://git-scm.com/docs/git-remote>, allows management of one
or more named deployment targets. We've just added a target named
C<flipr_test>, which means we can use the string C<flipr_test> for the target,
rather than the URI. But since we're doing so much testing, we can also tell
Sqitch to deploy to the C<flipr_test> target by default:

  > sqitch engine add snowflake flipr_test

Now we can omit the target argument altogether, unless we need to deploy to
another database. Which we will, eventually, but at least our examples will be
simpler from here on in, e.g.:

  > sqitch status
  # On database flipr_test
  # Project:  flipr
  # Change:   72ff6480c94724d772dae4136420e807688badb8
  # Name:     appschema
  # Deployed: 2018-07-25 17:35:46 -0400
  # By:       Marge N. O’Vera <marge@example.com>
  #
  Nothing to deploy (up-to-date)

Yay, that allows things to be a little more concise. Let's also make sure that
changes are verified after deploying them:

  > sqitch config --bool deploy.verify true
  > sqitch config --bool rebase.verify true

We'll see the L<C<rebase>|sqitch-rebase> command a bit later. In the meantime,
let's commit the new configuration and and make some more changes!

  > git commit -am 'Set default deployment target and always verify.'
  [master 09f7f5c] Set default deployment target and always verify.
   1 files changed, 8 insertions(+), 0 deletions(-)

=head1 More to Come

Sqitch is a work in progress. Better integration with version control systems
is planned to make managing idempotent reworkings even easier. Stay tuned.

=head1 Author

David E. Wheeler <david@justatheory.com>

=head1 License

Copyright (c) 2012-2018 iovation Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

=cut
