=head1 Name

sqitchtutorial - A tutorial introduction to Sqitch

=head1 Synopsis

  sqitch *

=head1 Description

This tutorial explains how to create a sqitch-enabled project, use a VCS for
deployment planning, and work with other developers to make sure changes
remain in sync and in the proper order.

We'll start by creating new project from scratch, the database for a fictional
antisocial networking site called Flipr. All examples use
L<Git|http://git-scm.com/> as the VCS and
L<PostgreSQL|http://www.postgresql.org/> as the storage engine, but for the
most part you can substitute other VCSes and database engines in the examples
as appropriate.

=head1 Starting a New Project

Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:

  > mkdir flipr
  > cd flipr 
  > git init .
  Initialized empty Git repository in /flipr/.git/
  > touch README.md
  > git add .
  > git commit -am 'Fist post!'

If you're a Git user and want to follow along the history, the repository
used in these examples is L<on GitHub|https://github.com/theory/sqitch-intro>.

Now that we have a repository, let's get started with Sqitch.

  > sqitch init --engine pg
  Created sqitch.ini
  Created sql/deploy
  Created sql/revert

Let's have a look at F<sqitch.ini>:

  [core]
      engine      = pg
      # sql_dir   = sql
      # extension = sql

Pretty simple. It picked up on the fact that we're creating changes for the
PostgreSQL engine, thanks to the C<--engine pg> option, and saved it to the
file. By default, Sqitch will read F<sqitch.ini> in the current directory for
settings. But it will also read F<~/.sqitch/config.ini> for global settings.
Since PostgreSQL's C<psql> client is not in the path on my system, let's go
ahead an tell it globally where to find the client:

  sqitch config --global core.pg.client /var/lib/pgsql/bin/psql

Have a look at F<~/.sqitch/config.ini> and you'll see this:

  [core.pg]
      client = /var/lib/pgsql/bin/psql

Back to the repository. Let's commit these changes and start creating the
database changes.

  > git add .
  > git commit -am 'Initialize Sqitch configuration.'

=head1 Our First Deployment

First, our project will need a database user. This is the application user,
who will have only limited access to objects in the database. Run this command:

  > sqitch add-step appuser
  Adding sql/deploy/appuser.sql
  Adding sql/revert/appuser.sql

The C<add-step> command creates deploy and revert scripts that represent a new
change step. Now we edit these files. The C<deploy> script's job is to create
the user. So we add this to F<sql/deploy/appuser.sql>:

  CREATE ROLE flipr WITH LOGIN;

The C<revert> script's job is to precisely revert the change to the deploy
script, so we add this to F<sql/revert/appuser.sql>:

  DROP ROLE flipr;

Now we can try deploying this change:

  > sqitch --db-name flipr_test deploy --untracked
  Adding metadata tables to flipr_test
  Deploying HEAD+ to flipr_test
    - appuser

First Sqitch created the metadata tables used to track database changes. The
structure and name of the metadata tables varies between databases (PostgreSQL
uses a schema to namespace its metadata; MySQL and SQLite use a prefix). Next,
Sqitch deploys changes. Here it is deploying something called C<HEAD+>.
Normally you would see a tag here, but since we've just added the files and
they are not yet committed to Git, there is no tag. C<HEAD+> is a special tag
reserved for use by Sqitch. It's enabled only by the use of the C<--untracked>
option, which allows Sqitch to find an deploy untracked changes.

With this change deployed, if you connect to the database, you'll be able to
see the role:

  > psql -d flipr_test -c '\du flipr'
             List of roles
   Role name | Attributes | Member of 
  -----------+------------+-----------
   flipr     |            | {}

And we can also see how the deployment was recorded via the C<status> command,
which reads the metadata tables from the database:

  > sqitch -d flipr_test status
  # On database flipr_test
  # Tag:  HEAD+
  # Step: appuser
  # Date: 2012-04-09 18:43:45
  #
  Nothing to deploy (up-to-date)

Let's make sure that we can revert the change:

  > sqitch --db-name flipr_test revert
  Reverting all changes from flipr_test
    - appuser

And now the user should be gone:

  > psql -d flipr_test -c '\du flipr'
                                  List of roles
   Role name | Attributes | Member of 
  -----------+------------+-----------

And the status message should reflect as much:

  > sqitch -d flipr_test status --untracked
  # On database flipr_test
  # Nothing deployed.
  #
  # Changes not yet deployed:
  # * HEAD+
  #   appuser
  #
  Use "sqitch deploy --untracked" to deploy these changes

We've again used the C<--untracked> option, otherwise the C<appuser> step would
not appear in the list of "Changes not yet deployed."

We still have a record that the change happened, visible via the C<log>
command:

  > sqitch -d flipr_test log
  step appuser reverted
  By:   david
  Date: 2012-04-09 18:45:47
  Tag:  HEAD+

  step appuser deployed
  By:   david
  Date: 2012-04-09 18:43:45
  Tag:  HEAD+

Cool. Now let's commit it.

  > git add .
  > git commit -m 'Add app user.'
  [master 36acafd] Add app user.
   2 files changed, 2 insertions(+)
   create mode 100644 sql/deploy/appuser.sql
   create mode 100644 sql/revert/appuser.sql

And then deploy again:

  > sqitch --db-name flipr_test deploy
  Deploying 36acafd to flipr_test
    - appuser

Notice we no longer need the C<--untracked> option. That's because we've
committed the step to Git, so Sqitch can read it from the Git history. And now
the user should be back:

  > psql -d flipr_test -c '\du flipr'
             List of roles
   Role name | Attributes | Member of 
  -----------+------------+-----------
   flipr     |            | {}

When we look at the status, the deployment is tagged with the SHA1 of the
commit:

  > sqitch -d flipr_test status
  # On database flipr_test
  # Tag:  36acafd
  # Step: appuser
  # Date: 2012-04-09 18:52:42
  #
  Nothing to deploy (up-to-date)

=head1 More Configuration

I'm getting a little tired of always having to type C<--db-name flipr_test>,
aren't you? Let's just make that the default, shall we?

  sqitch config core.pg.db_name flipr_test

Now we can leave it out, unless we need to deploy to another database. Which
we will, eventually, but at least our examples will be simpler from here on
in, e.g.:

  > sqitch status
  # On database flipr_test
  # Tag:  36acafd
  # Step: appuser
  # Date: 2012-04-09 18:52:42
  #
  Nothing to deploy (up-to-date)

Yay, that allows things to be a little more concise. Let's make some more
changes!

=head1 Deploy with Dependency

Let's add another deployment, this time to create a table. Our app will need
users, of course, so we'll create a table for them. First, add the new step:

  > sqitch add-step users
  Adding sql/deploy/users.sql
  Adding sql/revert/users.sql

Now edit the scripts. In C<sql/deploy/users.sql>, we put:

  -- requires: appuser
  BEGIN;
  SET client_min_messages = 'warning';

  CREATE TABLE users (
      nickname  TEXT        PRIMARY KEY,
      password  TEXT        NOT NULL,
      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
  );

  GRANT SELECT ON users TO flipr;
  COMMIT;

A few things to notice here. On the first line, we've declared a dependency on
the C<appuser> step. Although that step has already been added and committed,
and therefore should always be applied before the C<users> step, it's a good
idea to be explicit about dependencies. This becomes especially important when
committing a number of steps at one time, such as when merging a patch or a
branch.

The syntax of the dependency declaration is simple: Before any other lines,
create an SQL C<--> comment that simply uses the word "requires" followed by a
colon and then a comma-delimited list of required steps. The requirements may
also be listed on separate lines, providing they all start with
C<-- requires:>.

Notice that all of the SQL code is wrapped in a transaction. This is handy for
PostgreSQL deployments, because DDLs are transactional. The upshot is that if
any part of the deployment fails, the whole step fails. Such may work
less-well for database engines that don't support transactional DDLs.

Just before the commit, the C<GRANT> command grants C<SELECT> access on the
table to the C<flipr> user created by the C<appuser> step. This is why we
need the dependency.

Now for the revert script. Add this to C<sql/revert/users.sql>:

  DROP TABLE users;

Couldn't be much simpler, right? Let's deploy this bad boy:

  > sqitch deploy --untracked
  Deploying HEAD+ to flipr_test
    - users

The C<users> table should have been created:

  > psql -d flipr_test -c '\d users'
                       Table "public.users"
    Column   |           Type           |       Modifiers        
  -----------+--------------------------+------------------------
   nickname  | text                     | not null
   password  | text                     | not null
   timestamp | timestamp with time zone | not null default now()
  Indexes:
      "users_pkey" PRIMARY KEY, btree (nickname)

Now have a look at the status:

  > sqitch -d flipr_test status
  # On database flipr_test
  # Tag:  HEAD+
  # Step: users
  # Date: 2012-04-09 20:41:31
  #
  Nothing to deploy (up-to-date)

Success! However, we've once again deployed an untracked change with no tags.
In general, we want tags, so let's revert the change:

  > sqitch revert --to 36acafd
  Reverting HEAD+ from flipr_test
  - users

Note that we've used the C<--to> option to revert only to the C<36acafd> tag,
which represents the deployment of the C<appuser> step. (You can see this tag
by running C<sqitch log>, in case you don't have your SHA1 hashes memorized).
Now commit and deploy again:

  > git add .
  > git commit -am 'Add users table.'
  [master fa650af] Add users table.
   2 files changed, 16 insertions(+)
   create mode 100644 sql/deploy/users.sql
   create mode 100644 sql/revert/users.sql
  > sqitch deploy
  Deploying fa650af to flipr_test
    - users

Looks good. Check the status:

  > sqitch status --show tags
  # On database flipr_test
  # Tag:  fa650af
  # Step: users
  # Date: 2012-04-09 20:45:23
  #
  # Tags:
  #    fa650af - 2012-04-09 20:45:23 - david
  #    36acafd - 2012-04-09 19:04:50 - david
  #
  Nothing to deploy (up-to-date)

Note the use of C<--show tags>, which adds the "Tags" section to the output,
so that we can use a list of what tags were deployed, when, and by whom.

=head1 Add Two at Once

Let's add a couple more steps to add functions for managing users.

  > sqitch add-step insert_user --requires users --requires appuser
  Adding sql/deploy/insert_user.sql
         -- requires: users, appuser
  Adding sql/revert/insert_user.sql

  > sqitch add-step change_pass --requires users --requires appuser
  Adding sql/deploy/change_pass.sql
         -- requires: users, appuser
  Adding sql/revert/change_pass.sql

Here we've taken advantage of the C<--requires> option to have Sqitch write
the stubbed C<deploy> file with the C<-- requires:> line already filled in.
Have a look:

  > cat sql/deploy/insert_user.sql
  -- requires: users, appuser
  

Nice, huh? Yeah, okay, so it's a little thing. Little things matter, am I
right? Let's write the code. Here's what C<sql/deploy/insert_user.sql> should
look like:

  -- requires: users, appuser
  
  BEGIN;

  CREATE OR REPLACE FUNCTION insert_user(
      nickname TEXT,
      password TEXT
  ) RETURNS VOID LANGUAGE SQL SECURITY DEFINER AS $$
      INSERT INTO users values($1, md5($2));
  $$;

  GRANT EXECUTE ON FUNCTION insert_user(TEXT, TEXT) to flipr;
  COMMIT;

And C<sql/revert/insert_user.sql> should look something like this:

  DROP FUNCTION insert_user(TEXT, TEXT);

Now for C<change_pass>; C<sql/deploy/change_pass.sql> might look like this:

  -- requires: users, appuser

  BEGIN;

  CREATE OR REPLACE FUNCTION change_pass(
      nick    TEXT,
      oldpass TEXT,
      newpass TEXT
  ) RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER AS $$
  BEGIN
      UPDATE users
         SET password = md5($3)
       WHERE nickname = $1
         AND password = md5($2);
      RETURN FOUND;
  END;
  $$;

  GRANT EXECUTE ON FUNCTION change_pass(TEXT, TEXT, TEXT) to flipr;
  COMMIT;

And of course, its C<revert> script, C<sql/revert/change_pass.sql>, should look
something like:

  DROP FUNCTION change_pass(TEXT, TEXT, TEXT);

Test em out!

  > sqitch deploy --untracked
  Deploying HEAD+ to flipr_test
    - change_pass
    - insert_user

Do we have the functions?

  > psql -d flipr_test -c '\df'
                                      List of functions
   Schema |    Name     | Result data type |          Argument data types          |  Type  
  --------+-------------+------------------+---------------------------------------+--------
   public | change_pass | boolean          | nick text, oldpass text, newpass text | normal
   public | insert_user | void             | nickname text, password text          | normal

And what's the status?

  > sqitch status --show tags
  # On database flipr_test
  # Tag:  HEAD+
  # Step: insert_user
  # Date: 2012-04-09 20:45:23
  #
  # Tags:
  #    HEAD+   - 2012-04-09 20:45:23 - david
  #    fa650af - 2012-04-09 20:45:23 - david
  #    36acafd - 2012-04-09 19:04:50 - david
  #
  Nothing to deploy (up-to-date)

Looks good. Let's revert, commit, and re-deploy, as usual.

  > sqitch revert --to HEAD
  Reverting HEAD+ from flipr_test
    - insert_user
    - change_pass

Note the use of C<--to HEAD> to revert untracked changes. We also could have
explicitly used C<--to fa650af> to revert to that tag, but C<HEAD> is a nice
shortcut. Let's do the commit and re-deploy dance:

  > git add .
  > git ci -m 'Add `insert_user()` and `change_pass()`.'
  [master 803e6b8] Add `insert_user()` and `change_pass()`.
   4 files changed, 25 insertions(+)
   create mode 100644 sql/deploy/change_pass.sql
   create mode 100644 sql/deploy/insert_user.sql
   create mode 100644 sql/revert/change_pass.sql
   create mode 100644 sql/revert/insert_user.sql

  > sqitch deploy
  Deploying 803e6b8 to flipr_test
    - change_pass
    - insert_user

  > sqitch status --show tags
  # On database flipr_test
  # Tag:  HEAD+
  # Step: insert_user
  # Date: 2012-04-09 20:45:23
  #
  # Tags:
  #    803e6b8 - 2012-04-09 21:33:32 - david
  #    fa650af - 2012-04-09 20:45:23 - david
  #    36acafd - 2012-04-09 19:04:50 - david
  #
  Nothing to deploy (up-to-date)

Great, we're fully up-to-date!

=head1 Ship It!

Let's do a first release of our app. Let's call it C<1.0.0-dev1> Since we want
to have it go out with deployments tied to the release, let's tag it:

  > git tag v1.0.0-dev1 -am 'Tag v1.0.0-dev1'

We can test deployment to make sure the tag gets picked up like so:

  > createdb flipr_dev
  > sqitch --db-name flipr_dev deploy
  Deploying 36acafd to flipr_dev
    - appuser
  Deploying fa650af to flipr_dev
    - users
  Deploying 803e6b8/v1.0.0-dev1 to flipr_dev
    - insert_user
    - change_pass

All four steps were deployed, great! Let's have a look at the state:

  > sqitch --db-name flipr_dev status --show tags
  # On database flipr_dev
  # Tags: 803e6b8, v1.0.0-dev1
  # Step: change_pass
  # Date: 2012-04-09 22:14:00
  #
  # Tags:
  #    803e6b8, v1.0.0-dev1 - 2012-04-09 22:14:00 - david
  #    fa650af              - 2012-04-09 22:13:55 - david
  #    36acafd              - 2012-04-09 22:13:53 - david
  #
  Nothing to deploy (up-to-date)

Note that all the tags are included, and that the two tags C<803e6b8> and
C<v1.0.0-dev1> actually represent the same point in time. This is handy for
development, but is a bit over-the-top for production deployments. We can get
around this by bundling up all the steps with the explicit tag, leaving out
the individual commit SHA1s:

  > sqitch bundle --tags-only
  Bundling in bundle/
  Config written to bundle/sqitch.ini
  Bundling v1.0.0-dev1
    - appuser
    - users
    - change_pass
    - insert_user
  Plan written to bundle/sqitch.plan

Now we can package up the C<bundle> directory and distribute it. When it gets
installed somewhere, users can use Sqitch to deploy to the database. Of
course, the Git history is no longer available, so Sqitch will use the
C<sqitch.plan> file to figure things out. Let's have a look at it:

  cat bundle/sqitch.plan

  [v1.0.0-dev1]
  appuser
  users
  change_pass
  insert_user

Pretty simple. It shows the tag being deployed and the steps that constitute
it as a simple list. Notice that the SHA1s for each step are not present; the
C<--tags-only> option to the C<bundle> command limits the plan only to tags.

Let's test deploying it:

  > cd bundle
  > createdb flipr_prod
  > sqitch --db-name flipr_prod deploy
  Deploying v1.0.0-dev1 to flipr_prod
    - appuser
    - users
    - insert_user
    - change_pass

Looks much the same as before, eh? But have a look at the status:

  > sqitch --db-name flipr_prod status --show tags
  # On database flipr_prod
  # Tag:  v1.0.0-dev1
  # Step: change_pass
  # Date: 2012-04-09 22:17:38
  #
  # Tags:
  #    v1.0.0-dev1 - 2012-04-09 22:17:38 - david
  #
  Nothing to deploy (up-to-date)

No commit SHA1s, just C<v1.0.0-dev1>.

=head1 Flip Out

Now that we've got the basics of user management done, let's get to work on
the core of our product, the "flip." Since other folks are working on other
tasks in the repository, we'll work on a branch, so we can all stay out of
each other's way. So let's branch:

  > git checkout -b flips
  Switched to a new branch 'flips'

Now we can add a new step to create a table for our flips.

  > sqitch add-step flips --requires users
  Adding sql/deploy/flips.sql
         -- requires: users
  Adding sql/revert/flips.sql

You know the drill by now. Edit F<sql/deploy/flips.sql>:

  -- requires: users
  BEGIN;
  SET client_min_messages = 'warning';

  CREATE TABLE flips (
      id        BIGSERIAL   PRIMARY KEY,
      nickname  TEXT        NOT NULL REFERENCES users(nickname),
      body      TEXT        NOT NULL DEFAULT '' CHECK ( length(body) <= 180 ),
      timestamp TIMESTAMPTZ NOT NULL DEFAULT clock_timestamp()
  );

  GRANT SELECT ON flips TO flipr;
  COMMIT;

And edit F<sql/revert/flips.sql>:

  DROP TABLE flips;

And give it a whirl:

  > sqitch deploy --untracked
  Deploying HEAD+ to flipr_test
    - flips

Look good?

  > sqitch status --show tags
  # On database flipr_test
  # Tag:  HEAD+
  # Step: flips
  # Date: 2012-04-10 22:30:02
  #
  # Tags:
  #    HEAD+   - 2012-04-10 22:30:02 - david
  #    803e6b8 - 2012-04-09 21:33:32 - david
  #    fa650af - 2012-04-09 20:45:23 - david
  #    36acafd - 2012-04-09 19:04:50 - david
  #
  Nothing to deploy (up-to-date)

Yep. Make it so!

  > git add .
  > git commit -am 'Add flipr table.'
  [flips 4aa888e] Add flipr table.
   2 files changed, 18 insertions(+)
   create mode 100644 sql/deploy/flips.sql
   create mode 100644 sql/revert/flips.sql

Ooh, but wait, we forgot to revert the change before committing! Well,
no worries, we can update all the tags.

  > sqitch retag
  Retagging flipr_test
    . 36acafd
    . fa650af
    . 803e6b8
    + v1.0.0-dev1
    - HEAD+
    + 4aa888e
  Tags: 4 (1 removed, 1 added).

In the list of tags, C<.> means no change, C<+> means added, and C<-> means
removed.

Oh, it added the C<v1.0.0-dev1> tag. Recall that we never deployed it to the
test database before. That's cool, forgot about that. Then it removed the
C<HEAD+> tag and added C<4aa888e>. Let's examine the status:

  > sqitch status --show tags
  # On database flipr_test
  # Tag:  4aa888e
  # Step: flips
  # Date: 2012-04-10 22:30:02
  #
  # Tags:
  #    4aa888e              - 2012-04-10 22:30:02 - david
  #    803e6b8, v1.0.0-dev1 - 2012-04-09 21:33:32 - david
  #    fa650af              - 2012-04-09 20:45:23 - david
  #    36acafd              - 2012-04-09 19:04:50 - david
  #
  Nothing to deploy (up-to-date)

Great, looks like the tags are all in sync. That's handy. Of course, it's
still a good idea to test C<sqitch revert> and C<sqitch deploy> a few times,
just to make sure the changes are always carried out properly, but it's nice
to know we don't have to take extra steps just to commit untracked changes.

=head1 Wash, Rinse, Repeat

Now comes the time to add functions to manage flips. I'm sure you have things
nailed down now. Go ahead and add C<insert_flip> and C<delete_flip> steps
and commit them. The C<insert_flip> deploy script might look something like:

  -- requires: flips, appuser
  BEGIN;
  CREATE OR REPLACE FUNCTION insert_flip(
     nickname TEXT,
     body     TEXT
  ) RETURNS BIGINT LANGUAGE sql SECURITY DEFINER AS $$
      INSERT INTO flips (body, nickname)
      VALUES ($1, $2)
      RETURNING id;
  $$;
  GRANT EXECUTE ON FUNCTION insert_flip(TEXT, TEXT) to flipr;
  COMMIT;

And the C<delete_flip> deploy script might look something like:

  -- requires: flips, appuser
  BEGIN;
  CREATE OR REPLACE FUNCTION delete_flip(
     flip_id BIGINT
  ) RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER AS $$
  BEGIN
      DELETE FROM flips WHERE id = flip_id;
      RETURN FOUND;
  END;
  $$;
  GRANT EXECUTE ON FUNCTION delete_flip(BIGINT) to flipr;
  COMMIT;

The C<revert> scripts are:

  DROP FUNCTION insert_flip(TEXT, TEXT);

And:

  DROP FUNCTION delete_flip(BIGINT);

Check the L<example git repository|https://github.com/theory/sqitch-intro> for
the complete details. Test C<deploy> and C<revert>, commit, and C<retag>. The
status should end up looking something like this:

  > sqitch status --show tags
  # On database flipr_test
  # Tag:  74c49ef
  # Step: insert_flip
  # Date: 2012-04-10 23:00:29
  #
  # Tags:
  #    74c49ef              - 2012-04-10 23:00:29 - david
  #    4aa888e              - 2012-04-10 22:30:02 - david
  #    803e6b8, v1.0.0-dev1 - 2012-04-09 21:33:32 - david
  #    fa650af              - 2012-04-09 20:45:23 - david
  #    36acafd              - 2012-04-09 19:04:50 - david
  #
  Nothing to deploy (up-to-date)

Good, we've finished this feature. Time to merge back into C<master>.

=head1 Emergency

Let's do it:

  > git checkout master
  Switched to branch 'master'
  > git pull
  Updating 803e6b8..2fae0b3
  Fast-forward
   sql/deploy/delete_list.sql |   15 +++++++++++++++
   sql/deploy/insert_list.sql |   12 ++++++++++++
   sql/deploy/lists.sql       |   16 ++++++++++++++++
   sql/revert/delete_list.sql |    1 +
   sql/revert/insert_list.sql |    1 +
   sql/revert/lists.sql       |    2 ++
   12 files changed, 91 insertions(+)
   create mode 100644 sql/deploy/delete_list.sql
   create mode 100644 sql/deploy/insert_list.sql
   create mode 100644 sql/deploy/lists.sql
   create mode 100644 sql/revert/delete_list.sql
   create mode 100644 sql/revert/insert_list.sql
   create mode 100644 sql/revert/lists.sql

Hrm, that's interesting. Looks like someone made some changes to C<master>.
Looks like some list support was added. Well, let's see what happens when we
merge our changes.

  > git merge --no-ff flips
  Merge made by the 'recursive' strategy.
   sql/deploy/delete_flip.sql |   12 ++++++++++++
   sql/deploy/flips.sql       |   16 ++++++++++++++++
   sql/deploy/insert_flip.sql |   12 ++++++++++++
   sql/revert/delete_flip.sql |    1 +
   sql/revert/flips.sql       |    2 ++
   sql/revert/insert_flip.sql |    1 +
   6 files changed, 44 insertions(+)
   create mode 100644 sql/deploy/delete_flip.sql
   create mode 100644 sql/deploy/flips.sql
   create mode 100644 sql/deploy/insert_flip.sql
   create mode 100644 sql/revert/delete_flip.sql
   create mode 100644 sql/revert/flips.sql
   create mode 100644 sql/revert/insert_flip.sql

Hey, looks good, everything merged cleanly. Let's have a look at our Git history:

  > git log --oneline
  5e30f38 Merge branch 'flips'
  2fae0b3 Merge tag 'lists'
  2a84155 Merge branch 'lists'
  9703969 Add `insert_flip()` and `delete_flip()`.
  675f78d Add `insert_list()` and `delete_list()`.
  faaa4d0 Add flipr table.
  591e388 Add `lists` table.
  803e6b8 Add `insert_user()` and `change_pass()`.
  fa650af Add users table.
  36acafd Add app user.
  e076e84 Initialize Sqitch configuration.
  9ccc485 Add README text.
  7b8dd19 First post!

Whoa, wait, what? Recall that we left off at commit C<803e6b8>. After that we
should have our two commits to the "flips" branch and end with a merge commit.
But notice here we have some other stuff interleaved. Commit C<591e388> adds a
"lists" table before our C<faaa4d0> commit adds the "flips" table. Then there
is another interloper commit, C<675f78d>, which adds some functions to insert
and delete lists, before our C<9703969> commit adds functions to insert and
delete flips. And there, second from the top, is the explanation,
C<2fae0b3 Merge branch 'lists'>. Why, someone else was working on another
branch and merged stuff into master before we did! Now things are all mixed
up.

Well, the truth is, we got lazy. Those changes when we pulled master from the
origin should have raised a red flag. In truth, it's considered a bad practice
not to look at what's changed in C<master> before merging in a branch. What one
I<should> do is either:

=over

=item *

Rebase the branch from on master before merging. This "rewinds" the branch
changes, pulls from C<master>, and then replays the changes back on top of
C<master>.

=item *

Create a patch and apply I<that> to master. This is the sort of thing you
might have to do if you're sending changes to another user, especially if the
VCS is not Git.

=back

So let's restore things to how they were at master:

  > git reset --hard origin/master
  HEAD is now at 2fae0b3 Merge tag 'lists'

That throws out our merge, which thankfully we have not yet pushed. Now let's
go back to our branch and rebase it on C<master>:

  > git checkout flips
  Switched to branch 'flips'
  > git rebase master
  First, rewinding head to replay your work on top of it...
  Applying: Add flipr table.
  Applying: Add `insert_flip()` and `delete_flip()`.

Notice that it rewinds the changes since we branched from C<master>, pulls
from C<master>, and then re-applies our commits. Look at the Git log to make
sure things were applied properly:

  > git log --oneline
  54d680f Add `insert_flip()` and `delete_flip()`.
  d07f3dc Add flipr table.
  2fae0b3 Merge tag 'lists'
  2a84155 Merge branch 'lists'
  675f78d Add `insert_list()` and `delete_list()`.
  591e388 Add `lists` table.
  803e6b8 Add `insert_user()` and `change_pass()`.
  fa650af Add users table.
  36acafd Add app user.
  e076e84 Initialize Sqitch configuration.
  9ccc485 Add README text.
  7b8dd19 Fist post!

Much better. Now all of our "flips" changes come after the "lists" changes.
But wait, we can't merge into C<master> quite yet. Or, at least, it's not a
good idea. We need to first make sure that Sqitch deployments still work
properly.

  XXX Do that.

Now we can merge into C<master>:

  > git checkout master
  Switched to branch 'master'
  > git merge --no-ff flips
  Merge made by the 'recursive' strategy.
   sql/deploy/delete_flip.sql |   12 ++++++++++++
   sql/deploy/flips.sql       |   16 ++++++++++++++++
   sql/deploy/insert_flip.sql |   12 ++++++++++++
   sql/revert/delete_flip.sql |    1 +
   sql/revert/flips.sql       |    2 ++
   sql/revert/insert_flip.sql |    1 +
   6 files changed, 44 insertions(+)
   create mode 100644 sql/deploy/delete_flip.sql
   create mode 100644 sql/deploy/flips.sql
   create mode 100644 sql/deploy/insert_flip.sql
   create mode 100644 sql/revert/delete_flip.sql
   create mode 100644 sql/revert/flips.sql
   create mode 100644 sql/revert/insert_flip.sql

And double-check our work:

  > git log --oneline
  e161a90 Merge branch 'flips'
  54d680f Add `insert_flip()` and `delete_flip()`.
  d07f3dc Add flipr table.
  2fae0b3 Merge tag 'lists'
  2a84155 Merge branch 'lists'
  675f78d Add `insert_list()` and `delete_list()`.
  591e388 Add `lists` table.
  803e6b8 Add `insert_user()` and `change_pass()`.
  fa650af Add users table.
  36acafd Add app user.
  e076e84 Initialize Sqitch configuration.
  9ccc485 Add README text.
  7b8dd19 Fist post!

Much much better, all clean now.