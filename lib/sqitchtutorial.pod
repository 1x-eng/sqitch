=head1 Name

sqitchtutorial - A tutorial introduction to Sqitch

=head1 Synopsis

  sqitch *

=head1 Description

This tutorial explains how to create a sqitch-enabled project, use a VCS for
deployment planning, and work with other developers to make sure changes
remain in sync and in the proper order.

We'll start with a new project, from scratch, a fictional antisocial
networking site called Flipr. All examples use L<Git|http://git-scm.com/> as
the VCS and L<PostgreSQL|http://www.postgresql.org/> as the storage engine,
but for the most part you can substitute other VCSes and database engines in
the examples as appropriate.

=head1 Starting a New Project

Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:

  > mkdir flipr
  > cd flipr 
  > git init .
  Initialized empty Git repository in /flipr/.git/
  > touch README.md
  > git add .
  > git commit -am 'Fist post!'

If you're a Git user and want to follow along the history, the repository
used in these examples is L<on GitHub|https://github.com/theory/sqitch-intro>.

Now that we have a repository, let's get started with Sqitch.

  > sqitch init --engine pg
  Created sqitch.ini
  Created sql/deploy
  Created sql/revert

Let's have a look at F<sqitch.ini>:

  [core]
      engine      = pg
      # sql_dir   = sql
      # extension = sql

Pretty simple. It picked up on the fact that we're creating changes for the
PostgreSQL engine, thanks to the C<--engine pg> option, and saved it to the
file. By default, Sqitch will read F<sqitch.ini> in the current directory for
settings. But it will also read F<~/.sqitch/config.ini> for global settings.
Since PostgreSQL's C<psql> client is not in the path on my system, let's go
ahead an tell it globally where to find the client:

  sqitch config --global core.pg.client /var/lib/pgsql/bin/psql

Have a look at F<~/.sqitch/config.ini> and you'll see this:

  [core.pg]
      client = /var/lib/pgsql/bin/psql

Back to the repository. Let's commit these changes and start creating the
database changes.

  > git add .
  > git commit -am 'Initialize Sqitch configuration.'

=head1 Your First Deployment

First, our project will need a database user. This is the application user,
who will have only limited access to objects in the database. Run this command:

  > sqitch add-step appuser
  Adding sql/deploy/appuser.sql
  Adding sql/revert/appuser.sql

Now we can edit these files. The C<deploy> script should create the user. So add
this to the file:

  CREATE ROLE flipr WITH LOGIN;

The C<revert> script should drop the user, like so:

  DROP ROLE flipr;

Now we can try deploying this change:

  > sqitch --db-name flipr_test deploy --added
  Creating metadata schema on flipr_test to HEAD+
  Deploying to flipr_test
    - appuser

First Sqitch created the metadata schema it uses to track database changes.
The structure and name of the metadata may vary between databases (PostgreSQL
uses a schema to namespace its metadata; MySQL and SQLite use a object name
prefix). But if you connect to the database, you'll be able to see the role:

  > psql -d flipr_test -c '\du'
                                  List of roles
     Role name    |                   Attributes                   | Member of 
  ----------------+------------------------------------------------+-----------
   flipr          |                                                | {}
   postgres       | Superuser, Create role, Create DB, Replication | {}

And we can also see how the deployment was recorded in the C<sqitch.state> table:

  > psql -d flipr_test -c 'SELECT * FROM sqitch.state'
   step    | deployed_by | tags | requires | conflicts |          deployed_at          
  ---------+-------------+------+----------+-----------+-------------------------------
   appuser | david       | {}   | {}       | {}        | 2012-04-09 18:43:45.814606+00

Let's make sure that we can revert the change, as well:

  > sqitch --db-name flipr_test revert
  Revererting from flipr_test
  - appuser

And now the user should be gone:

  > psql -d flipr_test -c '\du'
                                  List of roles
     Role name    |                   Attributes                   | Member of 
  ----------------+------------------------------------------------+-----------
   postgres       | Superuser, Create role, Create DB, Replication | {}

And the C<appuser> state should be removed from the state, as well:

  > psql -d flipr_test -c 'SELECT * FROM sqitch.state'
   step | deployed_by | tags | requires | conflicts | deployed_at 
  ------+-------------+------+----------+-----------+-------------

Great, no records. We still have a record that it happened, though, in the
C<sqitch.history> table:

  > psql -d flipr_test -c 'SELECT * FROM sqitch.history ORDER BY taken_at'
   action |  step   | taken_by | tags | requires | conflicts |           taken_at            
  --------+---------+----------+------+----------+-----------+-------------------------------
   deploy | appuser | david    | {}   | {}       | {}        | 2012-04-09 18:43:45.814606+00
   revert | appuser | david    | {}   | {}       | {}        | 2012-04-09 18:45:47.705876+00

Awesome. So we have a complete record of our changes. This might be useful for
auditing purposes.

Now let's commit it.

  > git add .
  > git commit -m 'Add app user.'
  [master 36acafd] Add app user.
   2 files changed, 2 insertions(+)
   create mode 100644 sql/deploy/appuser.sql
   create mode 100644 sql/revert/appuser.sql

And then deploy again:

  > sqitch --db-name flipr_test deploy
  Deploying to flipr_test
    - appuser

Notice we no longer need the C<--added> option. That's because we've committed
the step to Git, so Sqitch can read it from the Git history. And now the user
should be back:

  > psql -d flipr_test -c '\du'
                                  List of roles
     Role name    |                   Attributes                   | Member of 
  ----------------+------------------------------------------------+-----------
   flipr          |                                                | {}
   postgres       | Superuser, Create role, Create DB, Replication | {}

When we look at the state, the deployment is tagged with the SHA1 of the
commit:

  > psql -d flipr_test -c 'SELECT * FROM sqitch.state'
    step   | deployed_by |   tags    | requires | conflicts |          deployed_at          
  ---------+-------------+-----------+----------+-----------+-------------------------------
   appuser | david       | {36acafd} | {}       | {}        | 2012-04-09 19:04:50.115235+00

=head1 Add a Table

Let's add another deployment, this time to create a table. Our app will need
users, of course, so let's create a table for them. First, add the new step:

  > sqitch add-step users
  Adding sql/deploy/users.sql
  Adding sql/revert/users.sql

Now edit the scripts. In C<sql/deploy/users.sql>, we put:

  -- requires: appuser
  BEGIN;
  SET client_min_messages = 'warning';

  CREATE TABLE users (
      nickname  TEXT        PRIMARY KEY,
      password  TEXT        NOT NULL,
      timestamp TIMESTAMPTZ NOT NULL DEFAULT NOW()
  );

  GRANT SELECT ON users TO flipr;
  COMMIT;

A few things to notice here. On the first line, we've declared a dependency on
the C<appuser> step. Although the step has already been added and committed,
so it should always be applied before the C<users> step, it's a good idea to
always be explicit about dependencies on other steps. This becomes especially
important when committing a number of steps at one time, such as when merging
a patch or a branch.

The syntax of the dependency declaration is simple: Before any other lines,
create an SQL C<--> comment that simply uses the word "requires" followed by a
colon and then a comma-delimited list of required steps. The requirements may
also be listed on separate lines, providing they all start with
C<-- requires:>.

Notice that all of the SQL code is wrapped in a transaction. This is handy for
PostgreSQL deployments, because DDLs are transactional. The upshot is that if
any part of the deployment fails, it all fails. Such may work less-well for
database engines that don't support transactional DDLs.

Just before the commit, the C<GRANT> command grant C<SELECT> access on the
table to the C<flipr> user created in the C<appuser> step. This is why we
declare the dependency.

Now for the revert script. Add this to C<sql/revert/users.sql>:

  DROP TABLE users;

Couldn't be much simpler, right? Let's deploy this bad boy:

  > sqitch --db-name flipr_test deploy --added
  Creating metadata schema on flipr_test to HEAD+
  Deploying to flipr_test
    - users

The C<users> table should have been created:

  > psql -d flipr_test -c '\d users'
                       Table "public.users"
    Column   |           Type           |       Modifiers        
  -----------+--------------------------+------------------------
   nickname  | text                     | not null
   password  | text                     | not null
   timestamp | timestamp with time zone | not null default now()
  Indexes:
      "users_pkey" PRIMARY KEY, btree (nickname)

Now have a look at the state:

  > psql -d flipr_test -c 'SELECT * FROM sqitch.state ORDER BY deployed_at'
    step   | deployed_by |   tags    | requires  | conflicts |          deployed_at          
  ---------+-------------+-----------+-----------+-----------+-------------------------------
   appuser | david       | {36acafd} | {}        | {}        | 2012-04-09 19:04:50.115235+00
   users   | david       | {}        | {appuser} | {}        | 2012-04-09 20:41:31.932729+00

Note that is has properly recorded the dependency on the C<appuser> state. But
there are no tags because the deployment has not yet been committed to Git. In
general, we want tags, so let's revert the change, commit, and deploy again:

  > sqitch --db-name flipr_test revert --to appuser
  Revererting from flipr_test
  - users

  > git add .
  > git commit -am 'Add users table.'
  [master fa650af] Add users table.
   2 files changed, 16 insertions(+)
   create mode 100644 sql/deploy/users.sql
   create mode 100644 sql/revert/users.sql
  > sqitch -d flipr_test deploy
  Deploying to flipr_test
    - users

  > psql -d flipr_test -c 'SELECT * FROM sqitch.state ORDER BY deployed_at'
    step   | deployed_by |   tags    | requires  | conflicts |          deployed_at          
  ---------+-------------+-----------+-----------+-----------+-------------------------------
   appuser | david       | {36acafd} | {}        | {}        | 2012-04-09 19:04:50.115235+00
   users   | david       | {fa650af} | {appuser} | {}        | 2012-04-09 20:41:31.932729+00

Looking good. Let's add a few more deployments that add functions for managing
users.

    > sqitch add-step insert_user
